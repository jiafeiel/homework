# 通配符：主要就是匹配文件名  

查看前一个目录的信息用~-，切换目录只用-，俩者不通用
[0-9]：匹配数字范围，每次匹配一个
用[]表示范围时，横杠（-）两边一般是一个字符，[0-10]表示的是0到1的范围，后边的0和前面的范围重了。
预定义字符表示字符，加[]表示的才是字符的范围。
# touch：创建空文件或刷新时间戳
刷新时间是把文件的三个状态时间都刷新	
# cp：复制文件和目录
cp 源文件 目的文件 ，如果文件存在，则会覆盖内容
cp 多个文件 目录（必须是目录要不报错）
root用户中用的cp命令时别名并不是原命令，别名比原命令多了一个选项-i，在覆盖的时候会提示是否覆盖。普通用户用的是cp原命令。
如果目标文件存在，加—backup会在同目录下新建文件名~备份文件。-b一样。
复制文件夹时必须加-r（递归，访问本目录下的所有文件）
-a归档，就是备份，也可以复制文件夹
-preserve=[ATTR_LIST]可以保留文件的某个属性
-v可以看见复制的过程
-u支复制比目标文件时间近的文件，就是更新文件
-r复制目录，不存在目的目录就创建同名目录并复制到目录下，存在目的目录就新建同名目录作为子目录，如果目的目录有了源目录，就在同名的目录下创建一个源目录
-d保留文件链接：默认复制的是实际的文件，加上选项复制的就是链接文件，如果保留的链接属性，如果复制的文件有链接，那复制过来的就是链接文件
--backup=[格式]:定义了备份文件名的格式
复制到目的目录的父目录不存在会报错
cp 文件名{,新文件名尾}，对文件进行备份（当一个文件的名字很麻烦时用）
# 移动和重命名、删除  
## mv：移动或改名
1、在不同分区移动文件特别慢，同一个分区移动文件很快的原因
同一个分区移动文件，在磁盘上，数据没有动，只是改了目录信息就行，不同分区修改把文件复制过来，再分配目录和节点信息，
mv一次只能改一个文件名，一次修改多个文件名用rename，格式为：rename 被替换的字符 替换字符 文件
## rm:删除文件时，只是先把文件信息删除，回收节点号，磁盘数据不会立即删除，只是会加一个标记说没有其他引用，可以存储数据
当空间快满了的时候，删除一部分文件，空间会释放，如果没有释放说明有进程真正使用此文件夹的文件，先用>清空文件，然后再删除就会释放空间
生产中很少用此命令，一般都会用mv命令来代替以防发生数据误删。在root账户中用的也是命令别名
当删除一个文件时，可是存储空间却没有立即释放说明当前删除的文件中有正在被访问的
查看被删除却没有立即释放空间的文件 lsof |grep deleted，关闭相关正在使用的文件就会释放，想要安全的释放被删除的文件就用> /boot/bigfile，可以快速清空文件，释放空间
删除-文件，1、rm -- -文件 2、rm ./-文件（直接删除路径）
# tree：显示目录结构,
# mkdir建目录时必须有父目录，须加-p就自动生成父目录
# rmdir只能删空目录，加-p就会递归删除父目录
# 索引节点
文件系统保存文件的信息，每个文件的元数据都有一个inode编号，每一个文件都有唯一一个不同的编号，这个唯一是在一个分区中
ls -i查看文件的节点编号，判断俩文件是不是一个文件就是看节点号
存储文件元数据的就是节点表
文件名不在元数据里，而是在目录里，目录也是一个文件，存的数据就是文件的名字和节点编号的关系
每个分区的节点编号是有限的，可以用df -i查看每个分区的节点编号最多有多少个
空间用光了也许是真的没了，也有可能是节点用光了，节点会随着空间的大小而改变
如果要建的文件数量太多，会提示参数太大，可以用这个命令创建：echof{0..500000}| xargs touch
节点不够了提示和硬盘满了提示一样
文件太多，查看和删除都不会提示文件太多了，这时候删除目录就好了
在centos7节点编号是64的都是挂载点，在6中，过载的节点号是2，/sys和/proc的节点编号是1。
# 链接：
## 硬链接：对一个文件起多个名
文件详细信息权限后的数字表示链接数，链接数是这个文件有几个名称（硬链接），每个硬链接没有主次之分
硬链接和源文件除了名字都一样，就是把文件名和节点号连接起来
硬链接不能跨分区和设备，可以夸目录
不能对文件夹创建硬链接，容易出现死循环
每个文件夹都有两个硬链接，还有一个是隐藏的 。，如果有子目录，每个子目录都有一个。。，所以每多一个子目录就会多一个链接数 
删除任何一个名字其他名字都可以继续访问文件
## 软连接：
以l开头的文件信息是软连接文件
ln -s 文件 链接名
链接和文件不是同一个文件，把原文件删除软连接就会出错如果在源文件的目录下在新建个同名的文件，虽然不是同一个文件但软连接又恢复了，它只是指向一个文件名
软连接可以支持文件夹和跨分区，软连接只是一个指针
只要通过当前路径找到目标路径，并在目标路径下创建软连接，，软连接所在的目录通过寻找路径的方法找到源文件，即实现软连接的创建和联通。在使用相对路径建软连接时，默认文件和链接所在的目录是同一个目录，源文件的相对路径是相对于建立链接路径的相对路径。例如：ln -s ../../../data/f2 /d1/d2/d3/f2link(data和d1在root目录下)
创建软连接源文件用相对路径时，一定要相对于目的地址的路径，目的地址要写绝对路径，要不就是默认当前的目录
软硬链接的区别：1、是否为同一个文件2、跨分区3、链接数4、原始文件删除5、节点数是否相同6、原始文件和链接文件的大小7、支持目录8、硬链接相对路径时相对当前的路径，软连接则不同
# file：查看文件的类型
原理;通过查看文件的头部信息判断
-F：查询多个文件时，文件信息之间分隔符可以指定；例如：file -F”要使用的分割符” 文件
-L：如果查询的是一个软连接，加上选项可以查看链接指向的文件的类型。
-f可以把要判断的文件路径写在文件里，可以一起判断出来
不要用cat查看一个不知道的文件，容易出现乱码，提示符也会出现乱码，注销一下就好。
# I/O设备和管道
# 标准输入和输出
标准输入（STDIN）－0默认接受来自键盘的输入
标准输出（STDOUT）－1默认输出到终端窗口
标准错误（STDERR）－2默认输出到终端窗口
打开的文件都有一个fd（文件描述符）：内容是文件的输出输入指向，可以在内存文件中查看打开的文件的进程中fd文件
# I/O重定向：改变默认位置
> 文件内容会被覆盖，文件不会变
set -C禁止覆盖已有内容，但可以追加，执行这个命令后就不能再进行覆盖操作了，可以用强行覆盖
>|file强制覆盖
set +C允许覆盖
>>原有基础上，追加内容，>,>>和文件之间可以没有间隔
&>所有输出重定向，无论对错文件
2>把错误重定向到文件
命令 >文件 2>文件  ：标准输出和错误输出到不同的位置
ls /boot /错误目录  >文件1 2>文件2。顺序不影响最后结果
2>&1此类重定向顺序会影响最后的结果
# tr命令：转换和删除字符
tr ‘3个字符’’4个字符’进行一一对应的转换，没有对应的不进行转换
tr’4个字符’’3个字符’ 没对应的就与后面字符串最后一个对应，没有在第一个字符串的就不对应转换
-t一和二字符集一一对应转换，超出的不进行转换
-c取反 ，一般和d一起使用，对不在字符集的进行操作
-d删除出现在字符集的字符
-s压缩连续重复出现的字符为一个 
# 管道：使用（|）表示
命令1（输出）|命令2（输入）：默认处理左边的标准输出
在管道中用重定向：2>&1 或|&（老版本不支持，6和7都支持）。都可以把所有输出重定向管道的下一个命令。不能用&>,这个没用
# cat:键盘输入什么它就输出什么
cat <文件1>文件2==cp 文件1 文件2
单行重定向，不回车不重定向保存
多行重定向，cat >f1 <<开始符  回车后开始输出内容
最后用结束符（和开始符一样，不能多任何字符）结束
区别：单行是写一行保存一行，多行是全部写完再全部保存到文件
# mail默认收邮件
mail -s “标题” 用户
正文
。（回车后自动显示EOT结束）
mail.显示邮件，输入邮件编号就可以查看邮件的内容
mail -s “标题” 用户 <<开始字符
内容
结束字符（同开始字符）
# tar打包解包
打包：tar -cvf 打包生产的文件 对那个文件或目录打包
解包：tar -xvf
特殊情况：tar -cvf - /home |tar -xvf –
将/home里面的文件打包，但打包的数据不是记录文件，而是传送到石头都疼，经过管道后，将tar -cvf -/home传送给后面的tar- xvf -,后面这个-则是取前面一个命令的stdout,因此就不需要临时文件了。打包时候文件名字，就是解包后文件的名字	
# tee重定向时不仅写入文件还可以输出到屏幕上
who |tee 文件  会覆盖文件内容
不覆盖：who |tee -a  文件
# 用户、组合权限
3A：认证（验证身份）+授权（根据不同的身份分配权限）+审计（监控审查相关操作）	
## 用户（UID）
令牌;身份验证通过都会分配一个令牌
管理员：root，0
普通用户：1-60000（如果分配到60000，下次分配就会再从已经释放没有使用的小数分配，想要超过指定数字可以指定）
系统用户：1-499（6版本），1-999（7）对守护进程获取资源进行权限分配（给某一个程序使用，如果某个程序必须要登录用户运行，这个用户就是系统用户，系统启动后这些进程就运行）
登录用户：500+（6），1000+（7）交互式登录 
创建新用户时，会默认创建一个和他同名的组，并作为它的主组 
## 组
管理员组：（GID）root，0
普通组;
      系统组：1-499（6），1-999（7）
      普通组：500+，10000+
Linux允许用户名和组名同名，ll查询出，第一个名字是用户名后一个是组名，组的ID号也是可以相同的
用户和组的关系是多对多
安全上下文：每个进程都有一个环境，包括进程的发起者，进程所能访问资源的权限取决于进程的运行者的身份。
组的类别：主组和辅助组，一个用户必须要属于一个且只有一个主组
私有组：组和用户同名且只有一个用户
除了附加组其他都是附加组。一个用户可以属于零个或多个附加组
id 用户名，查看用户的信息UID是用户的ID，GID是用户的主组ID,groups是用户加入的组
## /etc/passwd:用户及其属性信息（用户名、密码、UID、主组ID、用户详细信息、家目录）
文件内一行信息代表一个用户
nologin是系统用户
name:用户名
password：
以前放的口令，后来为了安全全部存放在一个单独文件，为了兼容放一个x。pwunconv工具转换，就可以看见加密的密码密文,变回pwconv
UID：存放用户的ID
直接修改root的ID是可以的，系统是根据ID分配权限的，跟名字没有任何关系。修改完后查看ID还是登录时的ID，因为系统是在用户登录时获取的ID，只有不注销或退出就可以一直使用刚登录时的用户权限，用id命令直接查到的是刚登录的信息，用id 用户名查到的是修改后的信息，但是只有诶呦注销或退出，就可以使用刚登录的权限
如果系统没有管理员就会出现问题
解决方法：在开机菜单中按E键，在ifnames=0这行的最后加一个init /bin/bash，按ctrl+x启动，mount -a rw remount /，再把用户ID修改完就好了
GECOS描述信息，最好用工具改，要不会出现格式错误，可以用finger查看描述信息，用chfn 用户名 修改，清空要用选项，不要在里面写，清空则chsh –f’’等属性 用户 ，直接用修改，随便填字符都会输出，不填就不改
家目录usermod（可以修改很多的用户属性） –d修改
chsh –s shell类型 用户，修改用户的shell
getent passwd 用户，可以查看单个用户的信息，可以查看多个人的
## /etc/group：组及其属性信息
组名，口令，组的ID，组成员（附加组成员，用逗号隔开，只有一个成员，且是主组，也显示）
etc/shadow：用户密码及其相关属性（登录名，加密口令，最后一次口令更改时间（距离19700101的天数），最短有效期（口令使用多久后才可以改），口令有效期，口令过期提醒天（提前几天提醒口令过期），口令延长期，账户的有效期，保留字段）
加密算法文件：/etc/logindefs
修改加密的算法：authconfig—passalgo=算法 –update，只对修改后新建的用户管用，老用户还是用的老的加密算法
生成随机口令：openssl rand -base64
$6:sha512算法，$1:md5 $5:sha256
用grub-md5-crypt输入密码，让后会生产加密后的字符
用户名
加密口令
最后一个密码更改日期（距离197011的时间）
最短有效期：这个密码几天之内不能更改
最长有效期： 
口令的警报时间，提起几天提醒更改口令的时间，过期之后，出现立即更改口令，先输入旧密码在输新密码
口令的宽限期，如果过了宽限期就会锁定口令，没有设就可以随时改
账户有效期：
保留字段
最好用chage修 改，
chage 用户 ,可以直接更改用户的口令信息
chage –l 用户，查看用户的密码信息
## etc/gshadow：（组名，口令（有！表示被锁定或者禁用），组的管理员，组成员）
有些用户的口令有！，叹号表示锁定或禁用，俩叹号表示空口令。
普通用户主动加组需要组的口令
root用户添加用户到组
groupmems -a 用户 -g 组   ，添加完后，用户需要重新登录才会显示，因为系统需要重新获取ID
root删除组成员
groupmems -d 用户 -g 组
临时更改主组，可以用exit退出
newgrp 组名。需要输入组的口令，加入后新组就会临时成为主组
gpasswd 组（修改用户口令）什么也不输入时就是对口令无操作，可以用选项-r清空，再加入组时口令也就不用输入就可以（待定）
gpasswd -a 用户 组，对组添加用户
第三个字段是组的管理员，没有指定就默认root
文件操作
nano没有语法检查功能
vipw vigr具有语法检查功能，pwck和grpck具有命令格式检查功能
# 用户和组的管理命令
useradd（/etc/default/useradd创建用户默认配置文件） 
默认创建的家目录下的隐藏文件是复制SKEL=/etc/skel的文件
用户名 ，默认创建一个用户，同时创建一个同名的组作为主组，默认口令禁用（空口令可以直接登录）
/etc/login.defs修改密码的默认信息
-u 指定UID
-o可以使用同一个ID
新建系统用户是不会新建家目录，普通用户就可以
-c :useradd –c ‘描述信息’ 用户
-D显示默认配置文件信息
usermod 给用户添加附加组时需要加-a，不加就会把虽有的附加组覆盖掉
usermod –G 主组名 用户名，清掉所有的附加组也可以，usermod –G””用户名
userdel 用户名，删除用户，但是他的相关信息比如家目录邮箱还在
-r就会把用户和相关信息全删除
adduser 是useradd的软连接
# su（switch user）切换用户
第一种，su 用户名（非完全切换，会保留原用户的环境信息，和重新登录不同）
第二种，su - 用户名（完全切换，和重新登录差不多）
都是用exit退回原用户，root用户切换可以直接切换，普通用户切换需要口令，不输入用户名切换，默认切换root用户
/etc/profile
当一个用户登录Linux系统或使用su -命令切换到另一个用户时，也就是Login shell 启动时，首先要确保执行的启动脚本就是 /etc/profile 。
只有Login shell 启动时才会运行 /etc/profile 这个脚本，而Non-login shell 不会调用这个脚本。要注意的是在/etc/profile 文件中设置的变量是全局变量。
/etc/profile.d
在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。
这些脚本文件之所以能够 被自动执行，是因为在/etc/profile 中使用一个for循环语句来调用这些脚本。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。
# gropadd(创建组)
删除组时，没有用户作为主组，用户正在登陆的组也不能删
文件权限（读r、写w、执行x）
对文件访问分为三类（文件所有者，文件所属组的成员，其他）
对文本文件适合读写权限，执行权限适合二进制文件
权限由三组权限组成，每组三个权限，-代表没有权限，分别为用户所有者权限、所属组权限，其他用户权限
# chmod修改权限
格式： chmod who opt per file
who(u(所有者)g(所属组)o(其他)a(所有人)
opt:+(增加一个权限)-（去掉一个权限）=（赋予一个权限，直接覆盖原来的权限），例：chmod o+w f1 （给其他用户增加一个对文件f1的写权限）
所有的文件设置的权限对root是不起作用的
chown 修改所有者
用户访问文件是，先判断是否为所有者，再判断是否为所数组，和其他用户，如果符合其中一个用户，就不往后判断
当所有者对自己的文件没有任何权限时，可以通过修改权限获取
用户所有者不可以通过修改所有者变更文件所有者
# 文件和目录权限
一个文件只设置了读权限，用软件是写不进去的，可以用命令追加或者清空
删除一个文件，得有对目录的写权限，因为删文件就是删除目录文件内容里的文件和节点号对用关系
文件有执行权限就会变绿 
只要文件没有执行权限，那么任何用户都不可以执行
没有对目录的修改权限就不能删除目录下的文件，没有读权限就不能查看目录下有什么文件，也不能用TAB键补全文件名，但是可以进入目录，如果知道提前知道目录有什么文件，是可以查看文件的
对目录只有读权限，可以浏览文件列表，不能进目录，也不能看文件内容和属性
对目录没有写权限，就不能删除和创建文件，如果没有执行权限也删除不了，因为进不去目录，所以就操作不了删除
chmod –R ：递归设置权限，就是对目录下的所有文件和文件夹，包括自己修改权限
如果指向对所有的目录设置执行权限，就使用X（大写），特例：(如果某一个文件的某一用户已经设置了执行权限，其他的用户也都会加上)
chmod --reference  文件1 文件2: 把文件1的权限复制给文件2
以上模式法设置权限
数字法设置权限：chmod 数字 文件
rwx,有就用1无就用0，三组分别用三个数字表示，在转换为八或十进制都可以。
chgrp 所属组 文件
修改所有者和所属组：chmod 所有者.所属组 文件，点后面没有就会把所有者设为所有组的名，点前面没有就只设置所有组，点和冒号等价
# 默认权限
新建用户时，四个配置文件都会更新
umask ：本身就是一个数字（四位，取后面三位）
umask的计算原理：对有权限的值进行遮挡
例：110110110
011010001umask值    下边是0上面的直接落下，下边1，落下0
umask+default=666（文件）|777(文件夹)
修改umask的值，将直接影响到新建文件和文件夹的权限默认值
用户设置。bashrc    全局设置 /etc/bashrc
在新建新文件时有一个特殊情况，如果算出的默认值有奇数就说明多减了1
umask值一样，为什么新文件和新文件夹的默认值不一样呢，因为在。bashrc文件里有一行判断代码，不是每个用户得到的umask是一样的（那修改umask是修改了哪里的）
umask –S：显示新建文件夹的默认值
也可以模式化设置默认值：umask u= h= o=
如果文件里有多个umask值，使用最后一个，前面的呗覆盖
# 特殊权限（先理解，二进制程序开发才会用到，普通生产中不用，只对二进制程序有效，脚本无效。Sticky作用在目录上）
# SUID SGID Sticky
## SUID 继承所属者的权限（只能对二进制程序文件设置特殊权限，对普通文件设置没有作用）
文件的所有者权限里带s，表示文件有特殊权限且是红的当用户调用这个文件时，就会临时切换为这个文件的所有者的权限。
当一些个工具文件有了s特殊权限就有可能会被别人利用
添加特殊权限就是u+s,数字表示法：用4表示特殊权限，加在普通权限的前面。chmod 4744 文件，这个数字是独立计算的
可以用chmod 普通权限数 ，设置权限时只写普通权限值就可以去掉
用file查看文件时有suid权限的会显示setud字符
当用u-s去掉权限时，s会变成S，用户会继承root身份
## SGID继承所属组的权限
添加方式：chmod g+s 文件，文件会变为黄色
sgid用2表示
chmod 6xxx 文件。就表示suid和sgid权限都有了
当作用在目录上时，只要是在这个目录下新建文件，文件的所属组就是目录的所属组
Sticky
添加：chmod o+t 目录，目录权限最后会有t文件名字变黑，背景不变
chmod 1xxx 目录。用1表示这个权限
有t的目录每个用户只能删除自己的文件，不能删除其他用户的文件
chattr +a 文件 ，只能追加内容和查看，其他都不能，清空也不行
chattr +i 文件, 限制root对文件不能删除更改，页不能删除文件的目录
修改属性后文件信息不显示，这属于文件的扩展属性显示用lsattr 文件
## ACL(依赖文件系统，6如果是后来手动添加的分区就不支持ACL功能)
df –T查看设备的文件系统
设置：setfacl –m u(如果是针对组用g):用户（组）：权限（没有任何权限用0或者-表示） 文件
被添加的文件权限最后会有一个加号，可以用getfacl文件，查看这个文件的acl权限
ACL权限生效顺序：所有者（如果是所有者后面的任何权限都不管用）
当用户属于多个组，其中有多个组自定义了ACL权限，则用户继承多个用户的权限
setfacl –x u（g）:用户（组） 文件，删除用户（组）的ACL权限
清空所有ACL权限：setfacl –b 文件
设置某个用户对整个目录的权限：setfacl –R u:用户:权限 目录
当chmod工具被禁用，就可以使用ACL权限
批量添加用户权限 setfacl –M 文件（内容是设置用户的权限） 文件
删除多个用户权限 setfacl –X 文件（要删除的用户和权限） 文件
当对目录设置ACL权限后，新建的文件是没有的，如果想在该目录下新建文件也有ACL权限：setfacl –R –m d:u(g):用户（组）：权限 目录
d表示默认 setfacl –k 文件夹，删除默认ACL权限
当复制一个ACL权限时加-p保留原文件的权限，直接复制，原文件的权限会丢
当打包或其他操作有可能会丢失文件的权限，可以用备份和恢复ACL
## mask（设置的ACL权限和mask权限比只少不多，相当于限制了最大权限）
当设置了ACL权限，在查看文件信息，显示的组权限被mask权限代替
当修改用户的权限时，mask的权限也同样修改了
直接修改mask的权限：setfacl –m mask::权限 文件，修改完后，添加的acl权限后面都会有一个#efftive：权限（刚才修改的mask权限），起作用的也是这个权限
设置了ACL权限后，maks权限就是文件所属组的权限
chmod g=权限 文件，其实修改的是mask的权限
# 文本处理工具（grep\sed\awk）
## 文件查看
cat:不分页，全部显示
-n加行号，-b对空行不加行号，-s把相邻的空行压缩为一行，-E显示换行加一个$，-A显示所有控制符，加入文件有一个tab，就会显示^I
cat<文件1>文件1，会清空文件1。cat <文件1>>文件2会在文件2里不停的复制无数信息
tac:竖着反向显示，和cat相反
rev横着反向显示
more 查看文件，翻到最后一页会退出
less翻到最后一页不会退出
head显示文件的前几行（默认显示十行）
tail显示文件的后几行
-f（跟踪文件的描述符）跟踪文件，查看文件不退出，一直跟踪文件的变化，如果把文件删了就不会跟踪了，-F（跟踪文件的名称）当文件删了，会显示文件不能访问，当文件新建后又可以显示文件的变化
tailf 类似tail –f 当文件不增长时并不访问文件
cut(从文件中取出特定的列)
cut –d分隔符 –f列
paste 合并两个文件同行号的列到一行
-s所有行合成一行
wc：统计文件字符（行数，单词数，字节数，文件）
sort（根据列来排序）
只写排序的文件其他不写，就会按照前面的字符开始排序
uniq：从输入中删除前后相接的重复的行
diff:比较两个文件的不同之处
把比较的结果存在文件3中（diff –u文件1 文件2>文件3），如果文件1或2有一个丢了，就可以根据另一个文件找回（patch –b 文件1\2 文件3），假如用文件1找回文件2，那找回的文件2的内容就会保存为文件1的名字，需要用用-b为文件1备份
## grep（文件过滤工具，以行过滤）
文本搜索，显示匹配内容的行
-v显示不包括的行
-q无论找到或没有找到都不显示，$?为0表示找到，为1表示没有找到
-A显示查到内容行后面的行内容 
-w显示保护匹配字符的单词
-f:grep –f文件1 文件2。读取文件1的内容在文件2中查找相匹配的字符行
# 基本正则表达式（BRE）man 7regex，主要处理字符串的
正则表达式（通配符扩展，匹配文件内容）
字符匹配，匹配次数，位置锚定
。放在[]外面表示匹配任意一个字符，放里面就是表示匹配点这个字符
*表示前一个字符出现次数不确定
。*表示任意个字符
## 位置锚定
^要放在[]外面，表示以匹配的字符开头的行
除了自读数字下划线其他字符都可以作为单词的分隔符
## 分组：用\(\)括号将一个或多个字符作为一个整体进行处理
后向引用：引用前面的分组括号的分组括号中的模式所匹配字符，而非模式
例：grep “\([0-9]\)\{3\}.*\1”\1表示第一个匹配到的字符而非模式
表示匹配一个行内容，前面出现的字符后面又出现了 :grep “\(字符\).*\1”文件 。\1表示的是第一个括号的字符 
grep “\(字符1\).*\(字符2\).*\2”,表示在一次匹配前面第二个括号的字符
括号嵌套：\(string1\+(string2\)*\),\1表示的是左边的第一个括号匹配的字符，就是表示整体的字符，\2表示的是第二个左括号开始的字符，表示的就是string2
或者\|
例：表示a或b开都的行，grep “^\(a\|b\)”文件，^与括号中的字符挨个组合匹配字符
